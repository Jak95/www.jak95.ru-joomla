<?php
// GlobeWeather 1.3.3 module - build 110429
// (c) 2010-2012 INNATO BV - www.innato.nl
// @license - http://www.gnu.org/licenses/gpl-2.0.html GNU/GPL
// **************************************************************************
// A metar station weather fetching module for Joomla! 1.6/1.7 by Innato B.V.
// **************************************************************************

// ensure this file is being included by a parent file
defined( '_JEXEC' ) or die( 'Restricted access' );

class weatherMetar
{

var $decoded_metar = array();
var $cache = NULL;
var $itime = '';
var $phenomena=NULL;
var $offset=NULL;

  // =======================================================================
  // This section contains user configurable items: The user can
  // configure the image filenames to be generated by the script.
  
  // An array to convert the weather group codes to an index of the
  // $images and $n_images array.
  
  var $phenomena_array = array ('#'  => 'None',
                                'TS' => 'Thun',
                                'RA' => 'Rain',
                                'DZ' => 'Rain',
                                'SN' => 'Snow',
                                'SG' => 'Snow',
                                'GR' => 'Hail',
                                'GS' => 'Hail',
                                'PE' => 'Hail',
                                'IC' => 'Hail',
                                'BR' => 'Fog',
                                'FG' => 'Fog');
  
  // An array to convert the cloud coverage codes to an index of the
  // $images and $n_images array.
  
  var $coverage = array ('CLR' => '0',
                         'SKC' => '0',
                         'FEW' => '1',
                         'SCT' => '2',
                         'BKN' => '3',
                         'OVC' => '4',
                         'VV'  => '4');
  
  var $sky_nodata_image = 'sky_nodata.png';
  
  // Define a lot of images for daylight weather-group/cloud
  // condition. It's a 2-dimensional array, indexed by the:
  // - Precipitation (first index)
  // - Cloud coverage (second index).

  var $images = array ('None'  => array ('0' => '0cloud.png',
                                         '1' => '1cloud_norain.png',
                                         '2' => '2cloud_norain.png',
                                         '3' => '3cloud_norain.png',
                                         '4' => '4cloud_norain.png'),
                       '-Rain' => array ('0' => '0cloud.png',
                                         '1' => '1cloud_lightrain.png',
                                         '2' => '2cloud_lightrain.png',
                                         '3' => '3cloud_lightrain.png',
                                         '4' => '4cloud_lightrain.png'),
                       'Rain'  => array ('0' => '0cloud.png',
                                         '1' => '1cloud_modrain.png',
                                         '2' => '2cloud_modrain.png',
                                         '3' => '3cloud_modrain.png',
                                         '4' => '4cloud_modrain.png'),
                       '+Rain' => array ('0' => '0cloud.png',
                                         '1' => '1cloud_heavyrain.png',
                                         '2' => '2cloud_heavyrain.png',
                                         '3' => '3cloud_heavyrain.png',
                                         '4' => '4cloud_heavyrain.png'),
                       '-Snow' => array ('0' => '0cloud.png',
                                         '1' => '2cloud_snow.png',
                                         '2' => '2cloud_snow.png',
                                         '3' => '3cloud_snow.png',
                                         '4' => '4cloud_lightsnow.png'),
                       '+Snow' => array ('0' => '0cloud.png',
                                         '1' => '2cloud_snow.png',
                                         '2' => '2cloud_snow.png',
                                         '3' => '3cloud_snow.png',
                                         '4' => '4cloud_heavysnow.png'),
                       '-Hail' => array ('0' => '0cloud.png',
                                         '1' => '2cloud_hail.png',
                                         '2' => '2cloud_hail.png',
                                         '3' => '3cloud_hail.png',
                                         '4' => '4cloud_lighthail.png'),
                       '+Hail' => array ('0' => '0cloud.png',
                                         '1' => '2cloud_hail.png',
                                         '2' => '2cloud_hail.png',
                                         '3' => '3cloud_hail.png',
                                         '4' => '4cloud_heavyhail.png'),
                       'Thun'  => array ('0' => '0cloud.png',
                                         '1' => '2cloud_thunders.png',
                                         '2' => '2cloud_thunders.png',
                                         '3' => '3cloud_thunders.png',
                                         '4' => '4cloud_thunders.png'),
                       'Fog'   => array ('0' => '0cloud_fog.png',
                                         '1' => '1cloud_fog.png',
                                         '2' => '2cloud_fog.png',
                                         '3' => '3cloud_fog.png',
                                         '4' => '4cloud_fog.png')
                       );

  // Define a lot of images for nigh time weather-group/cloud
  // condition. It has the same structure as the daylight array
  // $images It's a 2-dimensional array, indexed by the:
  // - Precipitation (first index)
  // - Cloud coverage (second index).

  var $n_images = array (
                         'None'   => array ('0' => 'n_0cloud.png',
                                            '1' => 'n_1cloud_norain.png',
                                            '2' => 'n_2cloud_norain.png',
                                            '3' => 'n_3cloud_norain.png',
                                            '4' => '4cloud_norain.png'),
                         '-Rain'  => array ('0' => 'n_0cloud.png',
                                            '1' => 'n_1cloud_lightrain.png',
                                            '2' => 'n_2cloud_lightrain.png',
                                            '3' => 'n_3cloud_lightrain.png',
                                            '4' => '4cloud_lightrain.png'),
                         'Rain'   => array ('0' => 'n_0cloud.png',
                                            '1' => 'n_1cloud_modrain.png',
                                            '2' => 'n_2cloud_modrain.png',
                                            '3' => 'n_3cloud_modrain.png',
                                            '4' => '4cloud_modrain.png'),
                         '+Rain'  => array ('0' => 'n_0cloud.png',
                                            '1' => 'n_1cloud_heavyrain.png',
                                            '2' => 'n_2cloud_heavyrain.png',
                                            '3' => 'n_3cloud_heavyrain.png',
                                            '4' => '4cloud_heavyrain.png'),
                         '-Snow'  => array ('0' => 'n_0cloud.png',
                                            '1' => 'n_2cloud_snow.png',
                                            '2' => 'n_2cloud_snow.png',
                                            '3' => 'n_3cloud_snow.png',
                                            '4' => '4cloud_lightsnow.png'),
                         '+Snow'  => array ('0' => 'n_0cloud.png',
                                            '1' => 'n_2cloud_snow.png',
                                            '2' => 'n_2cloud_snow.png',
                                            '3' => 'n_3cloud_snow.png',
                                            '4' => '4cloud_heavysnow.png'),
                         '-Hail'  => array ('0' => 'n_0cloud.png',
                                            '1' => 'n_2cloud_hail.png',
                                            '2' => 'n_2cloud_hail.png',
                                            '3' => 'n_3cloud_hail.png',
                                            '4' => '4cloud_lighthail.png'),
                         '+Hail'  => array ('0' => 'n_0cloud.png',
                                            '1' => 'n_2cloud_hail.png',
                                            '2' => 'n_2cloud_hail.png',
                                            '3' => 'n_3cloud_hail.png',
                                            '4' => '4cloud_heavyhail.png'),
                         'Thun'   => array ('0' => 'n_0cloud.png',
                                            '1' => 'n_2cloud_thunders.png',
                                            '2' => 'n_2cloud_thunders.png',
                                            '3' => 'n_3cloud_thunders.png',
                                            '4' => '4cloud_thunders.png'),
                         'Fog'    => array ('0' => 'n_0cloud_fog.png',
                                            '1' => 'n_1cloud_fog.png',
                                            '2' => 'n_2cloud_fog.png',
                                            '3' => 'n_3cloud_fog.png',
                                            '4' => '4cloud_fog.png')
                         );

// tries to connect to the web to fetch metar raw data
// detects if we are using cached data or not

function getMetar($station) {
	// get the metar retrieval mode
	if (isset($_SESSION['metar_mode'])) {
		$metar_mode = $_SESSION['metar_mode'];
	}
	else { // if metar mode not set, set it to HTTP1.
		$metar_mode = 'HTTP1';
	}
			
	$metar_cache_dir = JPATH_SITE."/modules/mod_globeweather/mod_globeweather/metar_data/";
	$metar_cache= $metar_cache_dir.$station."_metar_cache.txt";
	$metar = false;
	$_SESSION['metar_mode_configured'] = $metar_mode;	// for diagnostic purposes

	if (file_exists($metar_cache)) {
		$cache_age=(time()-filemtime($metar_cache));
		if (filesize($metar_cache)<30) { // probably something wrong with metar file
			$_SESSION['metar_mode_actual'] = 'cache NOK';
			$special_cache_age = $cache_age; // set special cache age - may not be greater than 5 mins to reload metar faster than configured cache parameter
		}
		else $special_cache_age = 0;
	}
	if (isset($cache_age) && $cache_age < $this->cache && file_exists($metar_cache) && $special_cache_age<300) {
		// reading cached metar data - also if file length zero. zero file retrieval is re-attempted in max 5 mins
		if (!isset($_SESSION['metar_mode_actual'])) {
			$_SESSION['metar_mode_actual'] = 'cache';
		}
	    $fp 	= @fopen($metar_cache, "r");
	    $metar	= @fread($fp, filesize($metar_cache));
	    @fclose($fp);
	}
	else {	// cached data expired or no data available
		// data retrieval protocol options http and ftp by Innato BV
		// Some ISPs have disabled http or FTP access to metar data.
		// Set the preferred mode in the module's parameters.
		// The software will try an alternative mode if the configured mode fails.

		$metar_retrieval_success = false;
		if (!isset($_SESSION['metar_ftp_option'])) {
			$_SESSION['metar_ftp_option'] = true;
		}
		if (!isset($_SESSION['metar_http1_option'])) {
			$_SESSION['metar_http1_option'] = true;
		}
		if (!isset($_SESSION['metar_http2_option'])) {
			$_SESSION['metar_http2_option'] = true;
		}
		
		if (!isset($_SESSION['metar_http3_option'])) {
			$_SESSION['metar_http3_option'] = true;
		}
		
		$helpers_dir = JPATH_SITE."/modules/mod_globeweather/mod_globeweather/helpers/";
	
		if ($metar_mode == 'HTTP1') {
			require ($helpers_dir.'metar_http1.php');
			if (!$metar_retrieval_success) {
				require ($helpers_dir.'metar_http2.php');
			}
			if (!$metar_retrieval_success) {
				require ($helpers_dir.'metar_http3.php');
			}
			if (!$metar_retrieval_success) {
				require ($helpers_dir.'metar_ftp.php');
			}
		}
		elseif ($metar_mode == 'FTP') {
			require ($helpers_dir.'metar_ftp.php');
			if (!$metar_retrieval_success) {
				require ($helpers_dir.'metar_http1.php');
			}
			if (!$metar_retrieval_success) {
				require ($helpers_dir.'metar_http2.php');
			}
			if (!$metar_retrieval_success) {
				require ($helpers_dir.'metar_http3.php');
			}
		}
		else {
			$_SESSION['metar_mode_actual'] = 'metar mode NOK';
		}
		
		// write metar cache file - also if string length is zero
		// set metar cache write permission
		if($_SESSION['metar_cache_perms_default'] !== $_SESSION['metar_cache_perms_write']) {
			set_dir_permissions($metar_cache_dir, $_SESSION['metar_cache_perms_write']);
		}
		if ($fp = @fopen($metar_cache, "w")) {
			fwrite($fp, $metar);
			fclose($fp);
		}
		// reset metar cache permissions
		if($_SESSION['metar_cache_perms_write'] !== $_SESSION['metar_cache_perms_default']) {
			set_dir_permissions($metar_cache_dir, $_SESSION['metar_cache_perms_default']);
		}
	}
	return $metar;
}

 function decode_metar($metar) {
    /* initialization */
    $temp_visibility_miles = '';
    $decoded_metar['remarks'] = '';
    $decoded_metar['location'] = '';

    /* Make sure we got the metar */
    $tmp_metar = $metar;

      $decoded_metar['metar'] = $tmp_metar;      

    /* We parse the METAR */
    $parts = explode(' ', $tmp_metar);	/* breaks up tmp_metar in individual parts */
    $num_parts = count($parts);
    
    for ($i = 0; $i < $num_parts; $i++) {
      $part = $parts[$i];

      if (preg_match('#RMK|TEMPO|BECMG|INTER#', $part)) {
        /* The rest of the METAR is either a remark or temporary
         * information. We keep the remark.
         */
		for($j=$i;$j<$num_parts; $j++)
		  $decoded_metar['remarks'] .= ' ' . $parts[$j];
	  
		$decoded_metar['remarks'] = trim($decoded_metar['remarks']);
	 	break;
      } elseif ($part == 'METAR') {
        /*
         * Type of Report: METAR
         */
		$decoded_metar['type'] = 'METAR';
      } elseif ($part == 'SPECI') {
        /*
         * Type of Report: SPECI
         */
		$decoded_metar['type'] = 'SPECI';
      } elseif (preg_match('#^[A-Z]{4}$#', $part) &&
                empty($decoded_metar['icao']))  {
        /*
         * Station Identifier
         */
		$decoded_metar['icao']  = $part;

    } elseif (preg_match('#([0-9]{2})([0-9]{2})([0-9]{2})Z#', $part, $regs)) {

	    if ($regs[1] > gmdate('j')) {
   	     $month = gmdate('n') - 1;
		} else {
        $month = gmdate('n');
		}

		// decoded metar time is unix time
		$decoded_metar['time'] =  gmmktime($regs[2] + intval($this->offset),$regs[3], 0, $month, $regs[1], gmdate('Y')) + 60*100*($this->offset - intval($this->offset));
	} elseif (preg_match('#(AUTO|COR|RTD|CC[A-Z]|RR[A-Z])#', $part, $regs)) {
        /*
         * Report Modifier: AUTO, COR, CCx or RRx
         */
        $decoded_metar['report_mod'] = $regs[1];
        
	} elseif (preg_match('#([0-9]{3}|VRB)([0-9]{2,3})G?([0-9]{2,3})?(KT|MPS|KMH)#', $part, $regs)) {
        
        /* Wind Group */
	
	$decoded_metar['wind']['deg'] = $regs[1];
	
	
	$this->store_speed($regs[2],
			   $regs[4],
			   $decoded_metar['wind']['knots'],
			   $decoded_metar['wind']['meters_per_second'],
			   $decoded_metar['wind']['miles_per_hour']);
	
	if (!empty($regs[3])) {
          
          /* We have a report with information about the gust.
           * First we have the gust measured in knots.
           */
	  $this->store_speed($regs[3],
			     $regs[4],
			     $decoded_metar['wind']['gust_knots'],
			     $decoded_metar['wind']['gust_meters_per_second'],
			     $decoded_metar['wind']['gust_miles_per_hour']);
	}
      } elseif (preg_match('#^([0-9]{3})V([0-9]{3})$#', $part, $regs) &&
                !empty($decoded_metar['wind'])) {
        
        /*
         * Variable wind-direction
         */
        $decoded_metar['wind']['var_beg'] = $regs[1];
	$decoded_metar['wind']['var_end'] = $regs[2];
      } elseif (preg_match('#^([0-9]{4})([NS]?[EW]?)$#', $part, $regs)) {
        /* 
         * Visibility in meters (4 digits only)
         */
        unset($group);

        if ($regs[1] == '0000') {
          /* Special low value */
          
	  $group['prefix'] = -1; /* Less than */
          $decoded_metar['visibility']['meter']  = 50;
          $decoded_metar['visibility']['km']     = 0.05;
          $decoded_metar['visibility']['ft']     = 164;
          $decoded_metar['visibility']['miles']  = 0.031;
	} elseif ($regs[1] == '9999') {
          /* Special high value */
          $decoded_metar['visibility']['prefix'] = 1;
          $decoded_metar['visibility']['meter']  = 10000;
          $decoded_metar['visibility']['km']     = 10;
          $decoded_metar['visibility']['ft']     = 32800;
          $decoded_metar['visibility']['miles']  = 6.2;
	} else {
          /* Normal visibility, returned in both small and large units. */
          $decoded_metar['visibility']['prefix'] = 0;
          $decoded_metar['visibility']['km']     = number_format($regs[1]/1000, 1);
          $decoded_metar['visibility']['miles']  = number_format($regs[1]/1609.344, 1);
          $decoded_metar['visibility']['meter']  = $regs[1] * 1;
          $decoded_metar['visibility']['ft']     = round($regs[1] * 3.28084);
	}
	if (!empty($regs[2])) {
	  $decoded_metar['visibility']['deg'] = $regs[2];
	}


      } elseif (preg_match('#^[0-9]$#', $part)) {
        /*
         * Temp Visibility Group, single digit followed by space.
         */
        $temp_visibility_miles = $part;
      } elseif (preg_match('#^M?(([0-9]?)[ ]?([0-9])(/?)([0-9]*))SM$#',
                     $temp_visibility_miles . ' ' . $part, $regs)) {
        /*
         * Visibility Group
         */
        unset($group);

	if ($regs[4] == '/') {
	  $vis_miles = $regs[2] + $regs[3]/$regs[5];
        } else {
          $vis_miles = $regs[1];
        }
        if ($regs[0][0] == 'M') {
          /* Prefix - less than */
          $decoded_metar['visibility']['prefix'] = -1;
        } else {
          $decoded_metar['visibility']['prefix'] = 0;
        }
        
        /* The visibility measured in miles */
        $decoded_metar['visibility']['miles']  = number_format($vis_miles, 1);
        
        /* The visibility measured in feet */
        $decoded_metar['visibility']['ft']     = round($vis_miles * 5280, 1);
        
        /* The visibility measured in kilometers */
        $decoded_metar['visibility']['km']     = number_format($vis_miles * 1.6093, 1);
        
        /* The visibility measured in meters */
        $decoded_metar['visibility']['meter']  = round($vis_miles * 1609.3);


      } elseif ($part == 'CAVOK') {
        /* CAVOK is used when the visibility is greater than 10
         * kilometers, the lowest cloud-base is at 5000 feet or more
         * and there is no significant weather.
         */

        $decoded_metar['visibility']['prefix'] = 1;
        $decoded_metar['visibility']['km']     = 10;
        $decoded_metar['visibility']['meter']  = 10000;
        $decoded_metar['visibility']['miles']  = 6.2;
        $decoded_metar['visibility']['ft']     = 32800;
        $decoded_metar['clouds'][]['condition'] = 'CAVOK';

      } elseif (preg_match('#^R([0-9]{2})([RLC]?)/([MP]?)([0-9]{4})' .
                     '([DNU]?)V?(P?)([0-9]{4})?([DNU]?)$#', $part, $regs)) {
        /* Runway-group */
        unset($group);
        $group['nr'] = $regs[1];
	if (!empty($regs[2])) {
	  $group['approach'] = $regs[2];
	}
	
	if (!empty($regs[7])) {
          /* We have both min and max visibility since $regs[7] holds
           * the max visibility.
           */
          if (!empty($regs[5])) { 
            /* $regs[5] is tendency for min visibility. */
            $group['min_tendency'] = $regs[5];
	  }
	  
          if (!empty($regs[8])) { 
            /* $regs[8] is tendency for max visibility. */
            $group['max_tendency'] = $regs[8];
	  }
	  
	  if ($regs[3] == 'M') {
            /* Less than. */
            $group['min_prefix'] = -1;
	  }
          $group['min_meter'] = $regs[4] * 1;
          $group['min_ft']    = round($regs[4] * 3.2808);
	  
	  if ($regs[6] == 'P') {
            /* Greater than. */
            $group['max_prefix'] = 1;
	  }
          $group['max_meter'] = $regs[7] * 1;
          $group['max_ft']    = round($regs[7] * 3.2808);
	  
	} else {
          /* We only have a single visibility. */
          
          if (!empty($regs[5])) { 
            /* $regs[5] holds the tendency for visibility. */
            $group['tendency'] = $regs[5];
	  }
	  
	  if ($regs[3] == 'M') {
            /* Less than. */
            $group['prefix'] = -1;
	  } elseif ($regs[3] == 'P') {
            /* Greater than. */
            $group['prefix'] = 1;
	  }
          $group['meter'] = $regs[4] * 1;
          $group['ft']    = round($regs[4] * 3.2808);
	}
        $decoded_metar['runway'][] = $group;



      } elseif (preg_match('#^(VC)?' .                           /* Proximity */
		     '(-|\+)?' .                          /* Intensity */
		     '(MI|PR|BC|DR|BL|SH|TS|FZ)?' .       /* Descriptor */
		     '((DZ|RA|SN|SG|IC|PL|GR|GS|UP)+)?' . /* Precipitation */
		     '(BR|FG|FU|VA|DU|SA|HZ|PY)?' .       /* Obscuration */
		     '(PO|SQ|FC|SS)?$#',                   /* Other */
		     $part, $regs)) {
        /*
         * Current weather-group.
         */
        $decoded_metar['weather'][] =
          @array('proximity'     => $regs[1],
                'intensity'     => $regs[2],
                'descriptor'    => $regs[3],
                'precipitation' => $regs[4],
                'obscuration'   => $regs[6],
                'other'         => $regs[7]);
        
      } elseif ($part == 'SKC' || $part == 'CLR') {
        /* Cloud-group */
        $decoded_metar['clouds'][]['condition'] = $part;
 
      } elseif (preg_match('#^(VV|FEW|SCT|BKN|OVC)([0-9]{3}|///)' .
                     '(CB|TCU)?$#', $part, $regs)) {
        /* We have found (another) a cloud-layer-group. */
        unset($group);

	$group['condition'] = $regs[1];
	if (!empty($regs[3])) {
	  $group['cumulus'] = $regs[3];
	}
	if ($regs[2] == '000') {
          /* '000' is a special height. */
          $group['ft']     = 100;
          $group['meter']  = 30;
          $group['prefix'] = -1; /* Less than */
	} elseif ($regs[2] == '///') {
          /* '///' means height nil */
          $group['ft']     = 'nil';
          $group['meter']  = 'nil';
	} else {
          $group['ft']     = $regs[2] *100;
          $group['meter']  = round($regs[2] * 30.48);
	}
        $decoded_metar['clouds'][] = $group;

      } elseif (preg_match('#^(M?[0-9]{2})/(M?[0-9]{2}|//)?$#', $part, $regs)) {
        /*
         * Temperature/Dew Point Group.
         */
		 
        $decoded_metar['temperature']['temp_c'] =
          round(strtr($regs[1], 'M', '-'));
        $decoded_metar['temperature']['temp_f'] =
          round(strtr($regs[1], 'M', '-') * (9/5) + 32);
          
        /* The dewpoint could be missing, this is indicated by the
         * second group being empty at most places, but in the UK they
         * use '//' instead of the missing temperature... */
		if (!empty($regs[2]) && $regs[2] != '//') {
			$decoded_metar['temperature']['dew_c'] =
			round(strtr($regs[2], 'M', '-'));
			$decoded_metar['temperature']['dew_f'] =
			round(strtr($regs[2], 'M', '-') * (9/5) + 32);
		}
		else {
			$decoded_metar['temperature']['dew_c'] = 'xxx';
			$decoded_metar['temperature']['dew_f'] = 'xxx';
		}
		
      } elseif (preg_match('#A([0-9]{4})#', $part, $regs)) {
        /*
         * Altimeter.
         * The pressure measured in inHg.
         */
        $decoded_metar['altimeter']['inhg'] =
          number_format($regs[1]/100, 2);
        
        /* The pressure measured in mmHg, hPa, mbar and atm */
        $decoded_metar['altimeter']['mmhg'] = number_format($regs[1] * 0.254, 1, '.', '');
        $decoded_metar['altimeter']['hpa'] = round($regs[1] * 0.33864);
        $decoded_metar['altimeter']['mbar'] = $decoded_metar['altimeter']['hpa'];
		$decoded_metar['altimeter']['atm'] = number_format($regs[1] * 3.3421e-4, 3, '.', '');
      } elseif (preg_match('#Q([0-9]{4})#', $part, $regs)) {
        /*
         * Altimeter.
         * The specification doesn't say anything about
         * the Qxxxx-form, but it's in the METARs.
         */
        
        /* The pressure measured in hPa and mbar */
        $decoded_metar['altimeter']['hpa']  = round($regs[1]);
        $decoded_metar['altimeter']['mbar'] = $decoded_metar['altimeter']['hpa'];
        
        /* The pressure measured in mmHg, inHg and atm */
        $decoded_metar['altimeter']['mmhg'] =
          number_format($regs[1] * 0.75006, 1, '.', '');
        $decoded_metar['altimeter']['inhg'] =
          number_format($regs[1] * 0.02953, 2);
        $decoded_metar['altimeter']['atm']  =
          number_format($regs[1] * 9.8692e-4, 3, '.', '');
      } elseif (preg_match('#^T([0-9]{4})([0-9]{4})#', $part, $regs)) {
        
        /*
         * Temperature/Dew Point Group, coded to tenth of degree Celsius.
         */
	$this->store_temp($regs[1] / 10,
			  $decoded_metar['temperature']['temp_c'],
			  $decoded_metar['temperature']['temp_f']);
	$this->store_temp($regs[2] / 10,
			  $decoded_metar['temperature']['dew_c'],
			  $decoded_metar['temperature']['dew_f']);
      } elseif (preg_match('#^T([0-9]{4}$)#', $part, $regs)) {
	$this->store_temp($regs[1],
			  $decoded_metar['temperature']['temp_c'],
			  $decoded_metar['temperature']['temp_f']);
      } elseif (preg_match('#^1([0-9]{4}$)#', $part, $regs)) {
        
        /*
         * 6 hour maximum temperature Celsius, coded to tenth of degree
         */
	$this->store_temp($regs[1] / 10,
			  $decoded_metar['temp_min_max']['max6h_c'],
			  $decoded_metar['temp_min_max']['max6h_f']);
      } elseif (preg_match('#^2([0-9]{4}$)#', $part, $regs)) {
        
        /*
         * 6 hour minimum temperature Celsius, coded to tenth of degree
         */
	$this->store_temp($regs[1] / 10,
			  $decoded_metar['temp_min_max']['min6h_c'],
			  $decoded_metar['temp_min_max']['min6h_f']);
      } elseif (preg_match('#^4([0-9]{4})([0-9]{4})$#', $part, $regs)) {
        
        /*
         * 24 hour maximum and minimum temperature Celsius, coded to
         * tenth of degree
         */
	$this->store_temp($regs[1] / 10,
			  $decoded_metar['temp_min_max']['max24h_c'],
			  $decoded_metar['temp_min_max']['max24h_f']);
	$this->store_temp($regs[2] / 10,
			  $decoded_metar['temp_min_max']['min24h_c'],
			  $decoded_metar['temp_min_max']['min24h_f']);
      } elseif (preg_match('#^P([0-9]{4})#', $part, $regs)) {
        
        /*
         * Precipitation during last hour in hundredths of an inch
         */
	if ($regs[1] == '0000') {
	  $decoded_metar['precipitation']['in'] = -1;
	  $decoded_metar['precipitation']['mm'] = -1;
	} else {
          $decoded_metar['precipitation']['in'] =
            number_format($regs[1]/100, 2);
          $decoded_metar['precipitation']['mm'] =
            number_format($regs[1]*0.254, 2);
	}
      } elseif (preg_match('#^6([0-9]{4})#', $part, $regs)) {
        
        /*
         * Precipitation during last 3 or 6 hours in hundredths of an
         * inch.
         */
	if ($regs[1] == '0000') {
	  $decoded_metar['precipitation']['in_6h'] = -1;
	  $decoded_metar['precipitation']['mm_6h'] = -1;
	} else {
          $decoded_metar['precipitation']['in_6h'] =
            number_format($regs[1]/100, 2);
          $decoded_metar['precipitation']['mm_6h'] =
            number_format($regs[1]*0.254, 2);
	}
      } elseif (preg_match('#^7([0-9]{4})#', $part, $regs)) {
        
        /*
         * Precipitation during last 24 hours in hundredths of an inch.
         */
	if ($regs[1] == '0000') {
	  $decoded_metar['precipitation']['in_24h'] = -1;
	  $decoded_metar['precipitation']['mm_24h'] = -1;
	} else {
          $decoded_metar['precipitation']['in_24h'] =
            number_format($regs[1]/100, 2, '.', '');
          $decoded_metar['precipitation']['mm_24h'] =
            number_format($regs[1]*0.254, 2, '.', '');
	}
      } elseif (preg_match('#^4/([0-9]{3})#', $part, $regs)) {
        
        /*
         * Snow depth in inches
         */
	if ($regs[1] == '0000') {
	  $decoded_metar['precipitation']['snow_in'] = -1;
	  $decoded_metar['precipitation']['snow_mm'] = -1;
	} else {
	  $decoded_metar['precipitation']['snow_in'] = $regs[1] * 1;
	  $decoded_metar['precipitation']['snow_mm'] = round($regs[1] * 25.4);
	}
      } else {
        
        /*
         * If we couldn't match the group, we assume that it was a
         * remark.
         */
	$decoded_metar['remarks'] .= ' ' . $part;
      }
    }
    
    /*
     * Relative humidity
     */
    if (!empty($decoded_metar['temperature']['temp_c']) &&
	!empty($decoded_metar['temperature']['dew_c']) && $decoded_metar['temperature']['dew_c'] !== 'xxx') {

      $decoded_metar['rel_humidity'] =
        number_format(pow(10, (1779.75 * ($decoded_metar['temperature']['dew_c'] -
                                          $decoded_metar['temperature']['temp_c'])
                               / ((237.3 + $decoded_metar['temperature']['dew_c']) *
                                  (237.3 + $decoded_metar['temperature']['temp_c']))
                               + 2)), 1);
    } 
    
    /*
     *  Compute windchill if temp < 40f and windspeed > 3 mph
     */
     if (!empty($decoded_metar['temperature']['temp_f']) &&
        !empty($decoded_metar['wind']['miles_per_hour']) && $decoded_metar['wind']['miles_per_hour'] >= 3)  {

		$decoded_metar['windchill']['windchill_f'] =
        round(35.74 + 0.6215*$decoded_metar['temperature']['temp_f']
                      - 35.75*pow((float)$decoded_metar['wind']['miles_per_hour'], 0.16)
                      + 0.4275*$decoded_metar['temperature']['temp_f'] *
                      pow((float)$decoded_metar['wind']['miles_per_hour'], 0.16));
		$decoded_metar['windchill']['windchill_c'] =
        round(13.112 + 0.6215*$decoded_metar['temperature']['temp_c']
                      - 13.37*pow(($decoded_metar['wind']['miles_per_hour']/1.609), 0.16)
                      + 0.3965*$decoded_metar['temperature']['temp_c'] *
                      pow(($decoded_metar['wind']['miles_per_hour']/1.609), 0.16));
    }
	else {
		$decoded_metar['windchill']['windchill_c'] = 'xxx';
		$decoded_metar['windchill']['windchill_f'] = 'xxx';
	}

    /*
     * Compute heat index if temp > 70F
     */
    if (!empty($decoded_metar['temperature']['temp_f']) &&
        $decoded_metar['temperature']['temp_f'] > 70 &&
        !empty($decoded_metar['rel_humidity'])) {
		$decoded_metar['heatindex']['heatindex_f'] =
        round(-42.379
                      + 2.04901523 * $decoded_metar['temperature']['temp_f']
                      + 10.1433312 * $decoded_metar['rel_humidity']
                      - 0.22475541 * $decoded_metar['temperature']['temp_f']
                                   * $decoded_metar['rel_humidity']
                      - 0.00683783 * $decoded_metar['temperature']['temp_f']
                                   * $decoded_metar['temperature']['temp_f']
                      - 0.05481717 * $decoded_metar['rel_humidity']
                                   * $decoded_metar['rel_humidity']
                      + 0.00122874 * $decoded_metar['temperature']['temp_f']
                                   * $decoded_metar['temperature']['temp_f']
                                   * $decoded_metar['rel_humidity']
                      + 0.00085282 * $decoded_metar['temperature']['temp_f']
                                   * $decoded_metar['rel_humidity']
                                   * $decoded_metar['rel_humidity']
                      - 0.00000199 * $decoded_metar['temperature']['temp_f']
                                   * $decoded_metar['temperature']['temp_f']
                                   * $decoded_metar['rel_humidity']
                                   * $decoded_metar['rel_humidity']);
		$decoded_metar['heatindex']['heatindex_c'] =
		round(($decoded_metar['heatindex']['heatindex_f'] - 32) / 1.8);
    }
	else {
		$decoded_metar['heatindex']['heatindex_c'] = 'xxx';
		$decoded_metar['heatindex']['heatindex_f'] = 'xxx';
	}


    /*
     * Compute the humidity index
     */
    if (!empty($decoded_metar['rel_humidity'])) {
      $e = (6.112 * pow(10, 7.5 * $decoded_metar['temperature']['temp_c']
                        / (237.7 + $decoded_metar['temperature']['temp_c']))
            * $decoded_metar['rel_humidity'] / 100) - 10;
      $decoded_metar['humidex']['humidex_c'] =
        number_format(round($decoded_metar['temperature']['temp_c'] + 5/9 * $e, 1), 1);
      $decoded_metar['humidex']['humidex_f'] =
        number_format(round($decoded_metar['humidex']['humidex_c'] * 9/5 + 32, 1), 1);
    }
	else {
		$decoded_metar['humidex']['humidex_c'] = 'xxx';
		$decoded_metar['humidex']['humidex_f'] = 'xxx';
	}


    /* Finally we store our decoded METAR in $this->decoded_metar so
     * that other methods can use it.
     */

    $this->decoded_metar = $decoded_metar;
    return $decoded_metar;
  }
  
 /**
   * Helper-function used to store temperatures.
   *
   * Given a numerical temperature $temp in Celsius, coded to tenth of
   * degree, store in $temp_c, convert to Fahrenheit and store in
   * $temp_f.
   *
   * @param string   Temperature to convert, coded to tenth of
   * 		     degree, like 1015
   * @param   integer   Temperature measured in degrees Celsius
   * @param   integer   Temperature measured in degrees Fahrenheit
   * @access  private
   */
  function store_temp($temp, &$temp_c, &$temp_f) {
    /*
     * Note: $temp is converted to negative if $temp > 100.0 (See
     * Federal Meteorological Handbook for groups T, 1, 2 and 4). 
     * For example, a temperature of 2.6°C and dew point of -1.5°C 
     * would be reported in the body of the report as "03/M01" and the
     * TsnT'T'T'snT'dT'dT'd group as "T00261015").  
     */
    
    if ($temp[0] == 1) {
      $temp[0] = '-';
    }
    $temp_c = number_format($temp,1);
    /* The temperature in Fahrenheit. */
    $temp_f = number_format($temp * (9/5) + 32, 1);
  }
  
  
  /**
   * Helper-function used to store speeds.
   *
   * $value is converted and stored based on $windunit.
   *
   * @param  float   The value one seeks to convert.
   * @param  string  The unit of $value.
   * @param  float &$knots   After $value has been converted into knots,
   *			     it will be stored in this variable.
   * @param  float &$meterspersec   After $value has been converted into
   *				    meters per second, it will be stored 
   *				    in this variable.
   * @param  float &$milesperhour   After $value has been converted into
   *				    miles per hour, it will be stored 
   *				    in this variable.
   * @access  private
   */
  function store_speed($value, $windunit, &$knots, &$meterspersec, &$milesperhour) {
    if ($value == 0) {
      $knots = 0;
      $meterspersec = 0;
      $milesperhour = 0;
      return;
    }
    
    if ($windunit == 'KT') {
      /* The windspeed measured in knots: */
      $knots        = number_format($value);
      /* The windspeed measured in meters per second, rounded to one
         decimal place  */
      $meterspersec = number_format($value * 0.5144, 1);
      /* The windspeed measured in miles per hour, rounded to one
         decimal place */
      $milesperhour = number_format($value * 1.1508, 1);
    } elseif ($windunit == 'MPS') {
      /* The windspeed measured in meters per second */
      $meterspersec = number_format($value);
      /* The windspeed measured in knots, rounded to one decimal
         place */
      $knots        = number_format($value / 0.5144, 1);
      /* The windspeed measured in miles per hour, rounded to one
         decimal place */
      $milesperhour = number_format($value / 0.5144 * 1.1508, 1);
    } elseif ($windunit == 'KMH') {
      /* The windspeed measured in kilometers per hour */
      $meterspersec = number_format($value * 1000 / 3600, 1);
      $knots        = number_format($value * 1000 / 3600 / 0.5144, 1);
      /* The windspeed measured in miles per hour, rounded to one
         decimal place */
      $milesperhour = number_format($knots * 1.1508, 1);
    }
  }
  
  // The get_sky_image() function takes the processed metar data and
  // returns the sky image filename. The function combines the weather
  // group and cloud group to a specific image. Example html code:
  //
  // <img src="< ?php
  //   get_image($processed_metar)
  // ? >" height="50" width="80" border="1">

  function get_sky_image($count_station_var, $time_zone_var) {
    $processed_metar_data = $this->decoded_metar;

    $metar = $processed_metar_data['metar'];

    $parts = explode(' ', $metar);
    $num_parts = count($parts);
	
	// initialise
    $night = 0;
    $maxcoverage = 0;

    for ($i = 0; $i < $num_parts; $i++) {
		$part = $parts[$i];
		$part = trim($part,'/');			/* RJA label trim - To solve wrong img problem when coverage data end with '///' like 'FEW020///' */
    
		if (preg_match('#RMK|TEMPO|BECMG#', $part)) {
			/* The rest of the METAR is either a remark or temporary
			information. We skip the rest of the METAR. */
			break;
			}
		elseif (preg_match('#([0-9]{2})([0-9]{2})([0-9]{2})Z#', $part, $regs)) {
// Get the parameters
			$station_id = $parts[0];
			$station_selected = $_SESSION['station_selected'];
			// time zone may contain minutes, separated from hour by decimal point
			// separate hours from minutes and calculate current local station time
			// current local time is used for day/night determination so that proper
			// icon type is shown when metar data are too old
			$local_time_minutes = gmdate('i') + 100*($time_zone_var - intval($time_zone_var));	/* station local time minutes */
			$local_time_hour = gmdate('H') + intval($time_zone_var);	/* station local time hour without daylight saving, i.e. winter time */
			
			// recalculate time if minutes are <0 or >60
			if($local_time_minutes > 59) {
				$local_time_hour += 1;
				$local_time_minutes = fmod($local_time_minutes,60);
			}
			else {
				if($local_time_minutes < 0) {
					$local_time_hour -= 1;
					$local_time_minutes = 60 + fmod($local_time_minutes,60);
				}
			}
			// read sunrise/set parameters
			$sunrise_hour = $_SESSION['sunrise_hour'];
			$sunset_hour = $_SESSION['sunset_hour'];
			$sunrise_hour_local = intval($sunrise_hour[$count_station_var]);
			$sunset_hour_local = intval($sunset_hour[$count_station_var]);

			if ($sunrise_hour_local == '')
				$sunrise_hour_local = 6;
			if ($sunset_hour_local == '')
				$sunset_hour_local = 18;
				
			if ($local_time_hour < 0) {
				$local_time_hour += 24;
				}
			elseif ($local_time_hour >= 24) {
				$local_time_hour -= 24;
			}
			
			if ($station_id == 'NZSP') {		/* South Pole (Antarctica) */
				$local_time_hour = date("md");		/* This is month_day not time ! */
				if (($local_time_hour >= "0321") && ($local_time_hour < "0921")) {
	    	        $night = 1;					/* Polar night between 21st Mar and 21 Sept */
				}
				}
			else {
				if (($local_time_hour < $sunrise_hour_local) || ($local_time_hour >= $sunset_hour_local)) {	// sunrise/sunset local time without daylight saving
					$night = 1;
					}
			}
		  }

      elseif (preg_match('#^(-|\+|VC)?(TS|SH|FZ|BL|DR|MI|BC|PR|RA|DZ|SN|SG|GR|GS|PE|IC|UP|BR|FG|FU|VA|DU|SA|HZ|PY|PO|SQ|FC|SS|DS)+$#', $part)) {
        /*
         * Is this the current weather group?
         */ 

        // Get the intensity and get rid of it in the $part string
        $intensity = '';      
        if (preg_match('#^(-|\+|VC)(..)*$#',$part)) {
          if ($part[0] == '-') {
            $intensity = '-';
            $part = substr($part,1);
          } elseif ($part[0] == '+') {
            $intensity = '+';
            $part = substr($part,1);
          } elseif ($part[0] . $part[1] == 'VC') {
            $intensity = '';
            $part = substr($part,2);
          }
        }

      
        // Now, take only the precipitation types that have images.
        // Ignore the others In case more then one exist, take only the
        // first one (highest predominance).
        preg_match('#(TS|RA|DZ|SN|SG|GR|GS|PE|IC|BR|FG)(..)*$#',$part,$match);
        if (!empty($match[1])) {
          $phenomena = $match[1];
        } else {
          preg_match('#(..)(TS|RA|DZ|SN|SG|GR|GS|PE|IC|BR|FG)(..)*$#',$part,$match);
          if (!empty($match[2])) {
            $phenomena = $match[2];
          } else {
            $phenomena = '#'; // No phenomena.
          }
        }
        // Not each precipitation type has a single image with it.
        // Combine similar precipitation types to a phenomena group.
        // I.e. drizzle (DZ) and rain (RA) are both considered to be
        // rain (as far as the images are concerned). Add intensity only
        // in case of rain and snow.
        if (preg_match('#^(Snow|Hail)$#',$this->phenomena_array[$phenomena])) {
          if ($intensity == '') {
            $intensity = '-';
          }
        }
            
        if (preg_match('#^(Rain|Snow|Hail)$#',$this->phenomena_array[$phenomena])) {
          $phenomena_group = $intensity . $this->phenomena_array[$phenomena];
        } else {
          $phenomena_group = $this->phenomena_array[$phenomena];
        }	

      }   
				
      // Now check the cloud coverage. There could be three cloud
      // layers, so check for all of them. Iconize the most covered
      // clouds, thus find the highest cloudcoverage layer, by
      // maximizing the $maxcoverage param
      
      elseif (preg_match('#(SKC|CLR)(...)#', $part, $regs)) {
        $maxcoverage = max($maxcoverage,$this->coverage[$regs[1]]);
        //      if ($maxcoverage < $this->coverage[$regs[1]]) {
        //        $maxcoverage = $this->coverage[$regs[1]];
        //      }
      }
      elseif (preg_match('#^(VV|FEW|SCT|BKN|OVC)([0-9]{3})(CB|TCU)?$#', $part, $regs)) {
        $maxcoverage = max($maxcoverage,$this->coverage[$regs[1]]);
        //      if ($maxcoverage < $this->coverage[$regs[1]]) {
        //        $maxcoverage = $this->coverage[$regs[1]];
        //      }
      }
    }
    // If looped through all groups and not found any weather group
    // (meaning no precipitation?), assume a '#' phenomena, resulting in
    // a 'None' phenomena group
    if (empty($phenomena)) {
      $phenomena = '#';
      $phenomena_group = $this->phenomena_array[$phenomena];
    }
         
    // At this point, the $phenomena_group variable contains the one
    // index of the $this->images array, while the $maxcoverage
    // variable contains the other index of the $this->images array.
    // The correct image can be selected from the array.

       $this->phenomena=$phenomena;

    if (($night == 1) || ($this->itime == 'nite')) {
      return @$this->n_images[$phenomena_group][$maxcoverage];
    } else { 
      return $this->images[$phenomena_group][$maxcoverage];
    }

  }

    function get_beaufort() {

    if (!empty($this->decoded_metar['wind'])) {
      $ms = $this->decoded_metar['wind']['meters_per_second'];
      $cnt = 0;
      while (($ms > $wind_speeds['ms'][$cnt]) && ($cnt <= 12)) {
        $cnt++;
      }
      return $cnt;
    } else {
      return 0;
    }
  }
  
    function get_wind_dir() {

    if (!empty($this->decoded_metar['wind'])) {
      $wind = $this->decoded_metar['wind'];
      if ($wind['deg']=='VRB') {
        $this->decoded_metar['wind']['deg']='';
        return "---";
      } elseif (($wind['deg'] == 0) && ($wind['knots'] == 0)) {
        return "---";
      } else {
        if (@$this->properties['reverse_dir']) {
          $rr=round($wind['deg']/22.5 + 8) % 16;
          return $rr;
        } else {
          $rr=round($wind['deg']/22.5);
          return $rr;
        }
      }
    } else {
      return "---";
    }
  }

} // end class

function chmod_file_glob($host,$port,$user,$pass,$file,$chmod) {
	// set up an ftp connection
	$conn_id = ftp_connect($host,$port); 

	// login with username and password
	$login_result = ftp_login($conn_id, $user, $pass);

	// try to chmod $file to $chmod - $chmod must be 4 digits, e.g. 0644
	$ftp_chmod_result = @ftp_chmod($conn_id, eval("return({$chmod});"), $file);

	// close the connection
	ftp_close($conn_id);
	
	return $ftp_chmod_result;
}
?>
